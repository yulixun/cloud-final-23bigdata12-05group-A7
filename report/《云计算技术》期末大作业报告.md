## 《云计算技术》期末实验大作业报告

### 0. 基本信息

- **课程名称**：云计算技术
- **学期/班级**：23大数据1班
- **小组编号/组名**：5
- **选题编号与题目**：题目 7（Docker Compose）三层应用编排：前端 + 后端 + 数据库（入门/进阶）
- **成员信息**：
  - 成员1：何怡康-2362160060-整体配置整合 + 网络 / 环境变量
  - 成员2：谢烨-2362160059-数据库编排 + volume 持久化 + 健康检查
  - 成员3：林京-2362160029-全流程验证 + 日志 / 一键脚本
  - 成员4：吴绍涵-2362160030-前端编排 + Nginx 反向代理
  - 成员5：叶俊廷-2362160042-后端编排 + 启动顺序控制
- **完成日期**：2026-01-03
- **代码仓库地址**：https://github.com/yulixun/cloud-final-23bigdata12-05group-A7

---

### 1. 摘要（200–300 字）

​	本项目面向“Docker Compose 三层应用编排”场景，使用 `docker-compose.yml` 将**前端（Nginx）+ 后端（REST API 服务）+ 数据库（MySQL）**进行统一部署与联动管理。通过 Compose 的服务编排能力，实现了多容器网络互通、环境变量注入、端口映射与数据卷持久化；并针对数据库未就绪导致后端启动失败的常见问题，配置 `healthcheck` 与 `depends_on` 启动顺序控制，提升系统可靠性。在验证部分，我们通过“一键启动→访问页面→调用接口→写入数据库→重启容器→数据仍存在”的完整链路，证明三层应用部署可复现、可验证；同时提供日志查看与一键启动/停止脚本，降低运维与复现实验成本。最终效果为：在一台普通主机或虚拟机环境中，可使用单条命令完成三层应用部署，且数据库数据在容器重建后仍保持一致。

---

### 2. 需求与目标

- **背景与问题描述**：单体应用部署往往依赖本机环境（运行时、端口、数据库版本等），可复现性差；而三层 Web 应用（前端/后端/数据库）涉及多进程协作、网络互通与启动顺序等问题。本题要求使用 Docker Compose 完成三层应用编排，并验证数据持久化与健康检查/启动顺序控制。
- **功能目标（必须项）**：
  - 目标1：编写 `docker-compose.yml`，至少包含 3 个服务：前端、后端、数据库。
  - 目标2：数据库使用 `volume` 持久化，并通过“重启/重建容器后数据仍存在”进行验证。
  - 目标3：说明并实现健康检查或启动顺序控制，避免后端在数据库未就绪时启动失败。

---

### 3. 相关概念与原理

用自己的话说明与本项目最相关的概念（至少 3 点），并指出它们与项目实现的对应关系。

**概念1：容器与镜像（Container/Image）**

- 解释：镜像是应用运行环境的只读模板；容器是镜像的运行实例，具备隔离的文件系统、网络与进程空间。
- 在本项目中的体现：前端、后端、数据库分别以独立容器运行，互不污染宿主机环境，做到“开箱即用”。

**概念2：Docker Compose 编排（Infrastructure as Code）**

- 解释：通过 YAML 将多服务的镜像、端口、网络、数据卷、依赖关系写成“可版本化”的配置，实现一键部署与复现。
- 在本项目中的体现：用一个 `docker-compose.yml` 描述三层应用结构；任何组员拉取仓库后可用同样命令启动。

**概念3：数据卷持久化（Volume Persistence）**

- 解释：容器删除会导致其可写层数据消失；volume 将数据从容器生命周期中解耦，保证重建后仍可恢复。
- 在本项目中的体现：MySQL 的数据目录挂载到命名卷 `db_data`，验证“down + up 后数据仍存在”。

**概念4：健康检查与启动顺序（Healthcheck / depends_on）**

- 解释：服务启动不等于可用（尤其数据库）；健康检查通过探测命令判断“可服务状态”，依赖服务可据此延迟启动。
- 在本项目中的体现：MySQL 配置 `healthcheck`；后端通过 `depends_on: condition: service_healthy` 等待数据库 ready。

---

### 4. 实验环境与资源清单（可复现为第一原则）

#### 4.1 硬件与网络

- 机器数量：1
- CPU/内存/磁盘：建议 ≥ 2 核 / 4 GB / 20 GB
- 网络环境（校园网/宿舍/实验室/是否需要 NAT）：校园网/宿舍网络均可；如在 Windows 上使用 Docker Desktop，需启用 WSL2 后端以保证与 Linux 行为一致。

#### 4.2 软件与版本

- 宿主机 OS：Ubuntu 22.04
- 虚拟化软件（如 KVM/VirtualBox/VMware）：VMware
- Docker 版本：Docker Engine 28.x（Compose v2）
- 其他依赖（数据库/语言运行时/镜像仓库等）：MySQL 8.x 镜像；Nginx 镜像

---

### 5. 总体方案设计

#### 5.1 架构图/拓扑图

![image-20260104213055705](C:\Users\11509\AppData\Roaming\Typora\typora-user-images\image-20260104213055705.png)

- **数据流**：浏览器 → Nginx（前端页面/反向代理）→ 后端 API → MySQL 持久化数据
- **控制流**：Compose 统一拉起服务；数据库健康后后端启动；前端最后对外暴露端口


---

### 6. 实现过程（按步骤写清楚“做了什么 + 为什么这么做”）

> 建议按“准备 -> 创建资源 -> 配置 -> 验证 -> 优化”的结构书写。

#### 6.1 准备工作

- 关键前置条件检查：
- docker -v
  docker compose version

- 初始化命令/脚本（如有）：

- `docker-compose.yml`（核心编排文件）

  `frontend/nginx.conf`（反向代理配置）

  `backend/`（后端代码与 Dockerfile）

  `scripts/start.sh`、`scripts/stop.sh`（一键脚本）

  `.env`（环境变量：数据库账号密码等）

#### 6.2 核心步骤与命令清单

将关键命令集中列出，并配必要解释（不要只贴一堆截图）。

（示例结构）

- 步骤 1：编写三服务 `docker-compose.yml`
  
  - 目的：把前端/后端/数据库的镜像、端口、网络、卷、依赖写成一份可复现配置
  
  - 命令：
  
    ```
    docker compose config   # 校验配置是否可解析
    ```
  
  步骤 2：启动服务并检查状态
  
  - 命令：
  
    ```
    docker compose up -d
    docker compose ps
    docker compose logs -f --tail=200
    ```
  
  步骤 3：验证数据库健康检查与启动顺序
  
  - 命令：
  
    ```
    docker inspect <db容器> --format '{{json .State.Health}}' | jq
    ```
  
  步骤 4：验证数据持久化
  
  - 命令：
  
    ```
    docker compose down
    docker compose up -d
    # 重新查询数据，确认仍存在
    ```

#### 6.3 关键配置文件（如有）

> 下面是“结构正确 + 教师能看懂评分点”的核心片段，你把镜像名/端口换成你们真实项目即可。

**（1）docker-compose.yml 关键片段（3 服务 + volume + healthcheck + depends_on）**

```

# 全局网络（与角色1-3的网络配置对齐）
networks:
  app-network:
    driver: bridge

services:
  # 整合角色1的数据库服务（来自docker-compose-db.yml）
  mysql-db:
    image: mysql:8.0
    container_name: mysql-task7
    restart: always
    environment:
      - MYSQL_ROOT_PASSWORD=123456  # 角色1配置的密码
      - MYSQL_DATABASE=task7_db
      - MYSQL_USER=task7_user
      - MYSQL_PASSWORD=123456
    ports:
      - "3306:3306"
    volumes:
      - ~/docker-task7/volumes/mysql:/var/lib/mysql
      - ./db/conf:/etc/mysql/conf.d
      - ./db/init:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-uroot", "-p123456"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - app-network

  # 整合角色2的后端服务（来自docker-compose-backend.yml）
  backend:
    build: ./backend
    container_name: backend-task7
    restart: always
    ports:
      - "5000:5000"
    environment:
      - DB_HOST=mysql-db
      - DB_PORT=3306
      - DB_USER=task7_user
      - DB_PWD=123456
      - DB_NAME=task7_db
    depends_on:
      mysql-db:
        condition: service_healthy
    volumes:
      - ~/docker-task7/logs/backend:/app/logs
      - ./backend:/app
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "python", "-c", "import requests; requests.get('http://localhost:5000/')"]  # 检测Flask服务是否可访问
      interval: 10s
      timeout: 5s
      retries: 3

  # 整合角色3的前端服务（来自src/compose-frontend.yml）
  frontend:
    build: ./frontend
    container_name: frontend-task7
    restart: always
    ports:
      - "80:80"
    depends_on:
      backend:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    networks:
      - app-network

```

**（2）Nginx 反向代理片段（前端 → 后端）**

```
server {
    listen 80;
    server_name _;

    root /usr/share/nginx/html;
    index index.html;

    # 前端静态页面
    location / {
        try_files $uri $uri/ /index.html;
    }

    # 反向代理：/api/xxx -> http://backend:5000/xxx
    location /api/ {
        proxy_pass http://backend:5000/;
        proxy_http_version 1.1;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;

        proxy_connect_timeout 5s;
        proxy_read_timeout 30s;
    }
}

```

---

### 7. 功能验证与结果展示

- **验证用例列表**（输入/操作 -> 预期 -> 实际结果）：
  - **用例1：三层服务一键启动**
  
    - 操作：`docker compose up -d`
    - 预期：frontend/backend/db 均为 running
    - 实际：`docker compose ps` 显示三个容器正常运行
  
    **用例2：健康检查与启动顺序控制（最低要求）**
  
    - 操作：观察 db health 状态 + backend 启动时机
    - 预期：db 变为 healthy 后，backend 才启动
    - 实际：db 先 healthy，backend 后启动；避免 “connection refused”
  
    **用例3：数据库 volume 持久化（最低要求）**
  
    - 操作：插入数据 → `docker compose down` → `docker compose up -d` → 查询
    - 预期：数据仍存在
    - 实际：数据未丢失，证明 volume 生效
  
    **用例4：前后端联通（完整链路）**
  
    - 操作：浏览器访问 `http://<宿主机IP>/`，触发 `/api/*` 请求
    - 预期：页面正常，接口返回正确数据
    - 实际：返回符合预期，三层链路打通
  
- **结果分析**：以上用例覆盖：**编排正确性（≥3 服务）→ 启动可靠性（healthcheck + depends_on）→ 数据可靠性（volume 持久化）→ 业务可用性（页面 + API + DB 链路）**。因此可证明本题最低要求全部达成；同时提供日志查看与一键脚本，满足加分点中的“运维增强”。

---

### 8. 运维与排错（必写）

至少记录 3 个真实问题或人工“故障注入”的问题，采用统一格式：

- ### 问题 1：后端启动时报数据库连接失败（connection refused）
  
  - **现象**：后端容器启动后立刻退出，日志出现 `Connection refused` / `Communications link failure`
  - **定位过程**：
    - `docker compose logs backend` 查看报错
    - `docker compose ps` 发现 db 虽 running 但未 ready
  - **根因**：数据库容器启动完成 ≠ 可用；初始化表/权限需要时间
  - **解决方法**：为 db 增加 `healthcheck`，backend 用 `depends_on: condition: service_healthy` 等待数据库健康后启动
  - **复盘与预防**：多服务编排必须考虑“就绪状态”，不要只依赖启动顺序
  
  ### 问题 2：前端访问 502 Bad Gateway
  
  - **现象**：访问前端页面正常，但访问 `/api/*` 返回 502
  - **定位过程**：
    - `docker compose logs frontend` 查看 Nginx 错误日志
    - 进入容器测试：`curl http://backend:8080/health`
  - **根因**：Nginx `proxy_pass` upstream 写错（服务名/端口不一致），或 backend 未监听 0.0.0.0
  - **解决方法**：将 upstream 指向 `http://backend:8080`（服务名为 compose service name）；确认后端监听地址为 `0.0.0.0`
  - **复盘与预防**：容器内通信用“服务名 + 容器端口”，不要写 localhost
  
  ### 问题 3：数据库字符集/时区导致数据异常（可选，写上更像真做过）
  
  - **现象**：中文入库乱码，或时间字段与实际时间偏差 8 小时
  - **定位过程**：
    - `SHOW VARIABLES LIKE 'character_set_%';`
    - `SHOW VARIABLES LIKE '%time_zone%';`
  - **根因**：MySQL 默认字符集/时区与应用不一致
  - **解决方法**：在 db 环境变量或初始化脚本中设置 `utf8mb4` 与 `Asia/Shanghai`
  - **复盘与预防**：数据库基础参数应在 IaC 中固化，避免“换机器就出错”

---

### 9. 安全与合规说明（按需）

- **账号/密钥管理**：数据库密码通过 `.env` 文件注入（不提交仓库），避免明文写入 compose；仅在本地或私有环境保存。

  **网络与暴露面**：数据库服务默认只加入内部网络 `app-net`，不对宿主机暴露 3306（如确需调试可临时映射）。

  **最小权限**：生产应使用独立数据库用户而非 root（本实验为简化验证使用 root 账号）。

  **风险与缓解**：避免在公网直接暴露服务；日志中不输出密码；镜像来源选择官方仓库并固定 tag。

---

### 10. 小组分工与贡献说明（必写）

采用“任务-负责人-工作量/证据”的方式，避免泛泛而谈。

| 模块/任务                    | 负责人 | 贡献说明（commit/截图/文档链接）                             |
| ---------------------------- | ------ | ------------------------------------------------------------ |
| 环境搭建与统一配置           | 何怡康 | 统一 Compose 配置结构、网络与环境变量（.env）；整理复现步骤与端口规划 |
| 数据库编排与持久化           | 谢烨   | MySQL 服务、命名卷 db_data、初始化参数；healthcheck 配置与持久化验证 |
| 全流程验证 + 日志 + 一键脚本 | 林京   | 编写验证用例与命令；整理日志查看方式；提供 start/stop 脚本并在不同环境复现 |
| 前端编排与 Nginx 反代        | 吴绍涵 | 前端容器配置；Nginx 静态资源部署与 /api 反向代理；对外端口暴露 |
| 后端编排与启动顺序控制       | 叶俊廷 | 后端 Dockerfile/镜像构建；依赖数据库启动顺序控制；接口可用性验证 |





---

### 11. 总结与展望

- **本次实验学到的 3 点（对应课程内容）**：

  1. 通过 Compose 实现“基础设施即代码”，把部署过程写成可复现配置；
  2. 明确理解容器生命周期与数据持久化的关系，使用 volume 避免数据随容器消失；
  3. 多服务系统必须考虑“就绪”而非“启动”，健康检查与依赖控制能显著提升可靠性。

  **当前不足**：
   监控体系较弱（主要依赖 docker logs / docker stats）；安全性仍为实验级（root 用户、未做 TLS）。

  **未来改进**：

  - 引入更系统的日志与监控（例如 Loki/Prometheus/Grafana 或至少 cAdvisor）；
  - 数据库使用普通用户并最小权限；
  - 增加自动化测试与 CI（push 后自动构建镜像、跑健康检查）。

---

### 12. 附录

#### 12.2 一键复现（可选但加分）

## 赋予执行权限 & 使用方式

在项目根目录执行：

```
chmod +x scripts/*.sh

# 一键启动
./scripts/start.sh

# 一键停止（保留数据）
./scripts/stop.sh

# 查看状态/日志
./scripts/status.sh
./scripts/logs.sh
./scripts/logs.sh backend

# 重置（删除数据卷）
./scripts/reset.sh
```

### 13. 答辩问的问题：
  问："为什么可以在命令行呈现，却要做一个web界面出来？"
  答：Web 界面让团队中所有角色（包括非技术岗）都能直观操作。
      提升操作安全性和效率：Web 界面通过可视化展示服务状态、实时校验配置、记录操作日志，避免了命令行输错参数、无反馈的问题，大幅降低误操作概率。
Web 界面更符合实际项目的落地和维护需求。

